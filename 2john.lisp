(defmacro sentence (&rest nodes)
  (labels
   ((h (Ptyp Mtyp)
       `(barnode ,Ptyp () (morph ,Mtyp () ,(pop nodes))))
    (hb (Ptyp Mtyp)
        `(barnode ,Ptyp () (morph ,Mtyp () ,(pop nodes)) ,(next)))
    (next ()
          (when (listp (car nodes))
            (setf nodes (append (car nodes) (cdr nodes))))
          (case (pop nodes)
                (A (h 'AP 'adjective))
                (C (hb 'CP 'complementizer))
                (C. `(barnode CP () nil ,(next)))
                (D (hb 'DP 'determiner))
                                        ;(J
                (N (h 'NP 'noun))
                (P (hb 'PP 'preposition))
                )))
   (prog1
       `(node SEN () ,(next))
     (print nodes)
     (assert (null nodes)))))
(defmacro simple (path &rest roots)
  (let ((chars (coerce (symbol-name path) 'list)))
    (labels
     ((nd ()
          (case (pop chars)
                (#\A `(barnode AP () (morph adjective () ,(pop roots))))
                (#\C `(barnode CP () (morph complementizer () ,(pop roots))
                               ,(nd)))
                (#\D `(barnode DP () (morph determiner () ,(pop roots)) ,(nd)))
                (#\J `(barnode conjP () ,(nd)
                               (morph conjunction () ,(pop roots)) ,(nd)))
                (#\M `(barnode-key NP () :head (morph noun () ,(pop roots))
                                   :spec ,(nd) :mod ,(nd) :comp ,(nd)))
                (#\N `(barnode NP () (morph noun () ,(pop roots))))
                (#\P `(barnode PP () (morph preposition () ,(pop roots)) ,(nd)))
                (#\R `(barnode DP () (morph pronoun () ,(pop roots))))
                (#\V `(barnode-key VP () :head (morph verb () ,(pop roots))
                                   :spec ,(nd) :bar ,(nd)))
                (#\! (pop roots))
                (#\_ nil))))
     (nd))))

(setf 2john
      (list
       (sentence P from D the N elder)
       ))
