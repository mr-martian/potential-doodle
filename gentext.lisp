(defmacro deflog (name args &body body)
  (let ((g (gensym)) (r (gensym)))
  `(progn
    (defun ,name ,args (format t "~A~%~%" (cons ',name (list ,@args)))
      (let ((,r (,g ,@args)))
        (format t "~A returns: ~A~%~%" ',name ,r)
        ,r))
    (defun ,g ,args ,@body))))
(defun choose (ls &optional len)
  (let ((l (or len (length ls))))
    (if (> l 1)
      (elt ls (random l))
      (car ls))))
(defun mapchild (fn node)
  (append (copy-tree (subseq node 0 3)) (mapcar fn (cdddr node))))
(defun is-list (l) (and (listp l) (not (symbolp (car l)))))
(defun match-pair (a b) (and (equal (car a) (car b)) (match (cdr a) (cdr b))))
(defun match (node1 node2)
  (cond
    ((or (equal node1 '?) (equal node2 '?)) t)
    ((and (listp node1) (listp node2))
      (if (and (is-list node1) (is-list node2))
        (or (subsetp node1 node2 :test #'match-pair)
            (subsetp node2 node1 :test #'match-pair))
      (and (= (length node1) (length node2)) (every #'match node1 node2)))
      )
    (t (equal node1 node2))))
(defun check-cond (vars conds)
  (every (lambda (c) (match (cdr c) (cdr (assoc (car c) vars)))) conds))
;When things go wrong, try uncommenting this and renaming (gen) to (-gen)
(defun gen (pats tree depth setvars)
  (format t "(gen pats ~A ~A ~A)~%~%" tree depth setvars)
  (let ((r (-gen pats tree depth setvars)))
    (format t "gen(~A) returns: ~A~%~%" depth r)
    r))
(defun gen (pats tree depth setvars)
  (cond
    ((symbolp tree) tree)
    ((is-list tree) (choose tree)) ;list of morphemes
    ((equal (car tree) 'variable)
      (let ((c (cdr (assoc 'optional (caddr tree))))
            (v (assoc (cadr tree) setvars)))
        (when (or (not c) (and c (< (random 100) (/ 10 depth))))
          (if v
            (cdr v)
            (gen pats (cdr (assoc (cadr tree) pats)) (1+ depth) setvars)))))
    ((or (equal (car tree) 'syntax) (eql (car tree) 'morphology))
      (mapchild (lambda (node) (gen pats node (1+ depth) setvars)) tree))
    ((equal (car tree) 'swap)
      (let* ((vrs (loop for v in (cadr tree)
                        collect (cons (car v) (gen pats (cdr v) depth setvars))))
             (len 0)
             (pts (loop for p in (cdddr tree) if (check-cond vrs (car p))
                        collect (cadr p) and do (incf len))))
        ;(format t "#######~%SWAP~%~A~%~A~%~A~%#######~%" vrs pts (cdddr tree))
        (gen pats (choose pts len) depth vrs)))
    (t tree))) ;morpheme
(defun trans (node pat)
  (labels ((getvars (n p)
            (cond
              ((and (listp p) (equal (car p) 'variable)) (cons (cadr p) n))
              ((and (listp n) (listp p))
                (loop for a in n for b in p appending (getvars a b)))
              ((match n p) nil)
              (t (return-from trans nil))))
          (putvars (p v)
            (if (listp p)
              (if (equal (car p) 'variable)
                (cdr (assoc (cadr p) v))
                (mapcar (lambda (x) (putvars x v)) p))
              p)))
    (putvars (cadr pat) (getvars node (car pat)))))
(defun product (ls)
  (if ls
    (let ((res (product (cdr ls))))
      (loop for a in (car ls) appending (loop for b in res collecting (cons a b))))
    (list nil)))
(defun translate (tree pats)
  (if (and tree (listp tree))
    (let* ((chls (mapcar (lambda (n) (translate n pats)) (cdddr tree)))
           (start (subseq tree 0 3))
           (nodes (mapcar (lambda (n) (append start n)) (product chls))))
      (loop for n in nodes appending (or (loop for p in pats when (trans n p) collect it) (list n))))
  (list tree)))

;;;;;;;;;;;;;;
;TEST
;;;;;;;;;;;;;;
(load "langs/2/gen.lisp")
(format t "~A~%" (gen *gen* (cdr (assoc *start* *gen*)) 1 nil))
