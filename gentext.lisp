(defmacro deflog (name args &body body)
  (let ((g (gensym)) (r (gensym)))
  `(progn
    (defun ,name ,args (format t "~A~%~%" (cons ',name (list ,@args)))
      (let ((,r (,g ,@args)))
        (format t "~A returns: ~A~%~%" ',name ,r)
        ,r))
    (defun ,g ,args ,@body))))
(defun choose (ls &optional len)
  (let ((l (or len (length ls))))
    (if (> l 1)
      (elt ls (random l))
      (car ls))))
(defun mapchild (fn node)
  (append (copy-tree (subseq node 0 3)) (mapcar fn (cdddr node))))
(defun is-list (l) (and (listp l) (not (symbolp (car l)))))
(defun match-pair (a b) (and (equal (car a) (car b)) (match (cdr a) (cdr b))))
(defun match (node1 node2)
  (cond
    ((or (equal node1 '?) (equal node2 '?)) t)
    ((and (listp node1) (listp node2))
      (if (and (is-list node1) (is-list node2))
        (or (subsetp node1 node2 :test #'match-pair)
            (subsetp node2 node1 :test #'match-pair))
      (and (= (length node1) (length node2)) (every #'match node1 node2)))
      )
    (t (equal node1 node2))))
(defun check-cond (vars conds)
  (every (lambda (c) (match (cdr c) (cdr (assoc (car c) vars)))) conds))
;When things go wrong, try uncommenting this and renaming (gen) to (-gen)
;(defun gen (pats tree depth setvars)
;  (format t "(gen pats ~A ~A ~A)~%~%" tree depth setvars)
;  (let ((r (-gen pats tree depth setvars)))
;    (format t "gen(~A) returns: ~A~%~%" depth r)
;    r))
(defun gen (pats tree depth setvars)
  (cond
    ((symbolp tree) tree)
    ((is-list tree) (choose tree)) ;list of morphemes
    ((equal (car tree) 'variable)
      (let ((c (cdr (assoc 'optional (caddr tree))))
            (v (assoc (cadr tree) setvars)))
        (when (or (not c) (and c (< (random 100) (/ 10 depth))))
          (if v
            (cdr v)
            (gen pats (cdr (assoc (cadr tree) pats)) (1+ depth) setvars)))))
    ((or (equal (car tree) 'syntax) (eql (car tree) 'morphology))
      (mapchild (lambda (node) (gen pats node (1+ depth) setvars)) tree))
    ((equal (car tree) 'swap)
      (let* ((vrs (loop for v in (cadr tree)
                        collect (cons (car v) (gen pats (cdr v) depth setvars))))
             (len 0)
             (pts (loop for p in (cdddr tree) if (check-cond vrs (car p))
                        collect (cadr p) and do (incf len))))
        ;(format t "#######~%SWAP~%~A~%~A~%~A~%#######~%" vrs pts (cdddr tree))
        (gen pats (choose pts len) depth vrs)))
    (t tree))) ;morpheme
(defun list-not-pair (x) (and (listp x) (listp (cdr x))))
(defun pair? (x) (and (listp x) (not (listp (cdr x)))))
(defun trans (node pat)
  (declare (optimize (speed 3) (safety 0)))
  (labels ((getvars (n p)
            (cond
              ((and (listp p) (equal (car p) 'variable)) (list (cons (cadr p) n)))
              ((and (list-not-pair n) (list-not-pair p))
                (loop for a in n for b in p appending (getvars a b)))
              ((and (pair? n) (pair? p))
                (list (getvars (car n) (car p)) (getvars (cdr n) (cdr p))))
              ((match n p) nil)
              (t (return-from trans nil))))
          (putvars (p v)
            (if (list-not-pair p)
              (if (equal (car p) 'variable)
                (cdr (assoc (cadr p) v))
                (mapcar (lambda (x) (putvars x v)) p))
              p)))
    (putvars (cadr pat) (getvars node (car pat)))))
(defun product (ls)
  (declare (optimize (speed 3) (safety 0)))
  (if ls
    (let ((res (product (cdr ls))))
      (loop for a in (car ls) appending (loop for b in res collecting (cons a b))))
    (list nil)))
(defun translate (tree pats)
  (declare (optimize (speed 3) (safety 0)))
  (if (and tree (list-not-pair tree))
    (let* ((chls (mapcar (lambda (n) (translate n pats)) (cdddr tree)))
           (start (subseq tree 0 3))
           (nodes (mapcar (lambda (n) (append start n)) (product chls)))
           (ret '()) (added nil))
      (mapcar (lambda (n)
                (setf added nil)
                (mapcar (lambda (p)
                          (let ((r (trans n p)))
                            (when r
                              (setf added t)
                              (push r ret))))
                        pats)
                (unless added (push n ret)))
              nodes)
      (remove-duplicates ret :test #'equal))
  (list tree)))
(defun to-python (tree)
  (if tree
    (case (car tree)
      (syntax (format nil "[~A~{ ~A~}]" (cadr tree) (mapcar #'to-python (cdddr tree))))
      (morphology (format nil "<~A ~A ~A>" (cadr tree) (to-python (fourth tree)) (to-python (fifth tree))))
      (morpheme (format nil "~A=~A" (cadr tree) (fourth tree)))
    )
    "~"))

;;;;;;;;;;;;;;
;TEST
;;;;;;;;;;;;;;
(load "langs/2/gen.lisp")
(setq sen (gen *gen* (cdr (assoc *start* *gen*)) 1 nil))
(setf sen2 '(SYNTAX -IP ((LANG . 2))
 (SYNTAX IP ((LANG . 2))
  (SYNTAX IBAR ((LANG . 2))
   (SYNTAX VP ((LANG . 2)) NIL (SYNTAX NP ((LANG . 2)) NIL (SYNTAX NMOD ((LANG . 2)) NIL NIL NIL (MORPHEME NOUN ((LANG . 2)) dyculm))) NIL
    (SYNTAX VBAR ((LANG . 2)) NIL (MORPHEME VERB ((LANG . 2) (TRANSITIVE . FALSE)) jeltan)))
   (MORPHEME AUXILLIARY ((LANG . 2)) golm))
  (SYNTAX NP ((LANG . 2)) NIL (SYNTAX NMOD ((LANG . 2)) NIL NIL NIL (MORPHEME NOUN ((LANG . 2)) jikin))))
 (MORPHEME CONJUNCTION ((LANG . 2) (CLAUSE-ONLY . FALSE)) keh)
 (SYNTAX IP ((LANG . 2))
  (SYNTAX IBAR ((LANG . 2))
   (SYNTAX VP ((LANG . 2)) NIL NIL NIL
    (SYNTAX VBAR ((LANG . 2)) (SYNTAX NP ((LANG . 2)) NIL (SYNTAX NMOD ((LANG . 2)) NIL NIL NIL (MORPHEME NOUN ((LANG . 2)) cejym)))
     (MORPHEME VERB ((LANG . 2) (TRANSITIVE . TRUE)) danec)))
   (MORPHEME AUXILLIARY ((LANG . 2)) molt))
  (SYNTAX NP ((LANG . 2)) NIL (SYNTAX NMOD ((LANG . 2)) NIL NIL NIL (MORPHEME NOUN ((LANG . 2)) gyznyt))))))
(format t "GENERATE:~%~A~%" sen)
(format t "MOVEMENT:~%~A~%" (translate sen *move*))
(time (setq tr (translate sen *trans*)))
;(format t "TRANSLATE (~A):~%~A~%" (length tr) (translate sen *trans*))
;(format t "TRANSLATE PYTHON:~%~{~A~%~}" (mapcar #'to-python tr))
(format t "TOTAL: ~A" (length tr))
